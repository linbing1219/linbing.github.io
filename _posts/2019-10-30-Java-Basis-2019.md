---
layout:     post
title:      JavaåŸºç¡€çŸ¥è¯†
subtitle:    "\"Java Basis\""
date:       2019-10-30
author:     Jimmy
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - JavaåŸºç¡€
    - Javaè¯­æ³•
    - Java
    - é¢è¯•
---

> â€œğŸ™‰ğŸ™‰ğŸ™‰ â€

## å‰è¨€
è¿™ç¯‡åšæ–‡ä¸»è¦è®°å½•ä¸‹Javaä¸­HashMapçš„ä¸€äº›çŸ¥è¯†ã€‚


## æ­£æ–‡

### HashMapå®ç°åŸç† [å‚è€ƒåšæ–‡](https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/)

åŸºäºMapæ¥å£å®ç°ï¼Œå…è®¸nullé”®/å€¼ã€éåŒæ­¥ã€ä¸ä¿è¯æœ‰åºã€ä¹Ÿä¸ä¿è¯åºå·ä¸éšæ—¶é—´å˜åŒ–ã€‚

ä¸¤ä¸ªé‡è¦çš„å‚æ•°ï¼šå®¹é‡(Capacity)å’Œè´Ÿè½½å› å­(Load factor)

ç®€å•çš„è¯´ï¼ŒCapacityå°±æ˜¯bucketsçš„æ•°ç›®ï¼ŒLoad factorå°±æ˜¯bucketså¡«æ»¡ç¨‹åº¦çš„æœ€å¤§æ¯”ä¾‹ã€‚å¦‚æœå¯¹è¿­ä»£æ€§èƒ½è¦æ±‚å¾ˆé«˜çš„è¯ä¸è¦æŠŠcapacityè®¾ç½®è¿‡å¤§ï¼Œä¹Ÿä¸è¦æŠŠload factorè®¾ç½®è¿‡å°ã€‚å½“bucketå¡«å……çš„æ•°ç›®ï¼ˆå³hashmapä¸­å…ƒç´ çš„ä¸ªæ•°ï¼‰å¤§äºcapacity*load factoræ—¶å°±éœ€è¦è°ƒæ•´bucketsçš„æ•°ç›®ä¸ºå½“å‰çš„2å€ã€‚

#### putå‡½æ•°çš„å®ç°

putå‡½æ•°å¤§è‡´çš„æ€è·¯ä¸ºï¼š

> 1. å¯¹keyçš„hashCode()åšhashï¼Œç„¶åå†è®¡ç®—index;
> 1. å¦‚æœæ²¡ç¢°æ’ç›´æ¥æ”¾åˆ°bucketé‡Œï¼›
> 1. å¦‚æœç¢°æ’äº†ï¼Œä»¥é“¾è¡¨çš„å½¢å¼å­˜åœ¨bucketsåï¼›
> 1. å¦‚æœç¢°æ’å¯¼è‡´é“¾è¡¨è¿‡é•¿(å¤§äºç­‰äºTREEIFY_THRESHOLD)ï¼Œå°±æŠŠé“¾è¡¨è½¬æ¢æˆçº¢é»‘æ ‘ï¼›
> 1. å¦‚æœèŠ‚ç‚¹å·²ç»å­˜åœ¨å°±æ›¿æ¢old value(ä¿è¯keyçš„å”¯ä¸€æ€§)
> 1. å¦‚æœbucketæ»¡äº†(è¶…è¿‡load factor*current capacity)ï¼Œå°±è¦resizeã€‚

ä»£ç å®ç°ï¼š
```
public V put(K key, V value) {
    // å¯¹keyçš„hashCode()åšhash
    return putVal(hash(key), key, value, false, true);
}
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // tabä¸ºç©ºåˆ™åˆ›å»º
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // è®¡ç®—indexï¼Œå¹¶å¯¹nullåšå¤„ç†
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        
        // èŠ‚ç‚¹å­˜åœ¨
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        // è¯¥é“¾ä¸ºæ ‘
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // è¯¥é“¾ä¸ºé“¾è¡¨
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        // å†™å…¥
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // è¶…è¿‡load factor*current capacityï¼Œresize
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

#### getå‡½æ•°çš„å®ç°

åœ¨ç†è§£äº†putä¹‹åï¼Œgetå°±å¾ˆç®€å•äº†ã€‚å¤§è‡´æ€è·¯å¦‚ä¸‹ï¼š

> 1. bucketé‡Œçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥å‘½ä¸­ï¼›
> 1. å¦‚æœæœ‰å†²çªï¼Œåˆ™é€šè¿‡key.equals(k)å»æŸ¥æ‰¾å¯¹åº”çš„entry
è‹¥ä¸ºæ ‘ï¼Œåˆ™åœ¨æ ‘ä¸­é€šè¿‡key.equals(k)æŸ¥æ‰¾ï¼ŒO(logn)ï¼›
è‹¥ä¸ºé“¾è¡¨ï¼Œåˆ™åœ¨é“¾è¡¨ä¸­é€šè¿‡key.equals(k)æŸ¥æ‰¾ï¼ŒO(n)ã€‚

ä»£ç å®ç°ï¼š
```
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        // ç›´æ¥å‘½ä¸­
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // æœªå‘½ä¸­
        if ((e = first.next) != null) {
            // åœ¨æ ‘ä¸­get
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            // åœ¨é“¾è¡¨ä¸­get
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

### JDK6ã€JDK7ã€JDK8å¯¹äºHashMapçš„ä¸åŒå®ç°

### HashMapå’ŒHashTableçš„åŒºåˆ«

> 1. å¹¶å‘å®‰å…¨ä¸å¹¶å‘ä¸å®‰å…¨ï¼šHashMapéåŒæ­¥ï¼ŒHashTableåŒæ­¥
> 1. HashMapå…è®¸keyæˆ–è€…valueä¸ºnullï¼Œè€ŒHashTableä¸å…è®¸
> 1. HashTableä¸­æ„é€ hashæ•°ç»„æ—¶initialCapacityé»˜è®¤å¤§å°æ˜¯11ï¼Œå¢åŠ çš„æ–¹å¼æ˜¯ old*2+1ã€‚HashMapä¸­æ„é€ hashæ•°ç»„æ—¶initialCapacityé»˜è®¤å¤§å°æ˜¯16ï¼Œè€Œä¸”ä¸€å®šæ˜¯2çš„æŒ‡æ•°ã€‚
> 1. å“ˆå¸Œå€¼çš„ä½¿ç”¨åŒºåˆ«ï¼šHashTableä½¿ç”¨å¯¹è±¡çš„hashcodeç›´æ¥å–æ¨¡ï¼Œè€ŒHashMapç”¨ä¸ä»£æ›¿å–æ¨¡ï¼ˆé«˜16ä½å¼‚æˆ–ä½16ä½ï¼‰
> 1. HashMap æŠŠ Hashtable çš„ contains æ–¹æ³•å»æ‰äº†ï¼Œæ”¹æˆ containsValue å’Œ containsKey

### HashMapéåŒæ­¥çš„é—®é¢˜
> 1. å¤šçº¿ç¨‹putåå¯èƒ½å¯¼è‡´getæ— é™å¾ªç¯ï¼ˆå¾ªç¯å¼•ç”¨ï¼‰
> 1. å¤šçº¿ç¨‹putåå¯èƒ½å¯¼è‡´å…ƒç´ ä¸¢å¤±ï¼ˆå†²çªç¢°æ’åè¦†ç›–ï¼‰

### å¦‚ä½•ä½¿HashMapçº¿æ€§å®‰å…¨ï¼Ÿ

- æ–¹æ³•1ï¼š
```
Map<String, String> synchronizedHashMap = Collections.synchronizedMap(new HashMap<String, String>());
```
> 1. ä¼šåŒæ­¥æ•´ä¸ªå¯¹è±¡
> 1. æ¯ä¸€æ¬¡çš„è¯»å†™æ“ä½œéƒ½éœ€è¦åŠ é”
> 1. å¯¹æ•´ä¸ªå¯¹è±¡åŠ é”ä¼šæå¤§é™ä½æ€§èƒ½
> 1. è¿™ç›¸å½“äºåªå…è®¸åŒä¸€æ—¶é—´å†…è‡³å¤šä¸€ä¸ªçº¿ç¨‹æ“ä½œæ•´ä¸ªMapï¼Œè€Œå…¶ä»–çº¿ç¨‹å¿…é¡»ç­‰å¾…
> 1. å®ƒæœ‰å¯èƒ½é€ æˆèµ„æºå†²çªï¼ˆæŸäº›çº¿ç¨‹ç­‰å¾…è¾ƒé•¿æ—¶é—´ï¼‰
> 1. SynchronizedHashMapä¼šè¿”å›Iteratorï¼Œå½“éå†æ—¶è¿›è¡Œä¿®æ”¹ä¼šæŠ›å‡ºå¼‚å¸¸

- æ–¹æ³•2ï¼š
```
ConcurrentHashMap<String, String> concurrentHashMap = new ConcurrentHashMap<>();
```
> 1. å½“ä½ ç¨‹åºéœ€è¦é«˜åº¦çš„å¹¶è¡ŒåŒ–çš„æ—¶å€™ï¼Œä½ åº”è¯¥ä½¿ç”¨ConcurrentHashMap
> 1. å°½ç®¡æ²¡æœ‰åŒæ­¥æ•´ä¸ªMapï¼Œä½†æ˜¯å®ƒä»ç„¶æ˜¯çº¿ç¨‹å®‰å…¨çš„
> 1. è¯»æ“ä½œéå¸¸å¿«ï¼Œè€Œå†™æ“ä½œåˆ™æ˜¯é€šè¿‡åŠ é”å®Œæˆçš„
> 1. åœ¨å¯¹è±¡å±‚æ¬¡ä¸Šä¸å­˜åœ¨é”ï¼ˆå³ä¸ä¼šé˜»å¡çº¿ç¨‹ï¼‰
> 1. é”çš„ç²’åº¦è®¾ç½®çš„éå¸¸å¥½ï¼Œåªå¯¹å“ˆå¸Œè¡¨çš„æŸä¸€ä¸ªkeyåŠ é”
> 1. ConcurrentHashMapä¸ä¼šæŠ›å‡ºConcurrentModificationExceptionï¼Œå³ä½¿ä¸€ä¸ªçº¿ç¨‹åœ¨éå†çš„åŒæ—¶ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹å°è¯•è¿›è¡Œä¿®æ”¹ã€‚
> 1. ConcurrentHashMapä¼šä½¿ç”¨å¤šä¸ªé”

- æ–¹æ³•3ï¼š
ä½¿ç”¨HashTableï¼Œå·²å¼ƒç”¨ã€‚
