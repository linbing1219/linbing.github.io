---
layout:     post
title:      Synchronized原理
subtitle:    "\"Synchronized Introduction\""
date:       2019-11-02
author:     Jimmy
header-img: img/shopping-coffee-machine-machines.jpg
catalog: true
tags:
    - Synchronized
    - Java
---

> “🙉🙉🙉 ”

## Synchronized实现原理

Synchronized可以作用于：
> 1. 静态方法 
> 1. 非静态方法
> 1. 代码块

## 对象锁与类锁

对象锁和类锁是两个锁，是相互独立互补影响的。

## 什么是可重入性，为什么说Synchronized是可重入锁

可重入锁是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

```
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```

## 什么是锁消除和锁粗化
### 锁粗化
短时间内大量请求、同步和释放锁会降低系统性能，所以在某些情况下，将多个锁请求合并成一个请求能降低这种性能损耗。

- 其中一种场景
```
public void doSomethingMethod(){
    synchronized(lock){
        //do some thing
    }
    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕
    synchronized(lock){
        //do other thing
    }
}
```

锁粗化优化：
```
public void doSomethingMethod(){
    synchronized(lock){
        //do some thing
    //这是还有一些代码，做其它不需要同步的工作，但能很快执行完毕
        //do other thing
    }
}
```

- 另一种场景

```
for(int i=0;i<size;i++){
    synchronized(lock){
    }
}
```

锁粗化优化：
```
synchronized(lock){
for(int i=0;i<size;i++){   
}
}
```

### 锁消除

锁消除是发生在编译器级别的一种锁优化方式。

锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。锁削除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 

逃逸分析：对象是否逃出其作用域？

## 悲观锁与乐观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。

乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

因此，悲观锁适合写操作比较多的场景，先加锁可以保证写操作时数据正确；而乐观锁适合读操作多的场景，不加锁能使其读操作性能大幅提高。

### CAS算法

为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

> 1. 需要读写的内存值 V
> 1. 进行比较的值 A
> 1. 要写入的新值 B

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

CAS存在的问题：
> 1. ABA的问题：在变量前面加上版本号，每次变量更新时版本号加1，例如1A->2B->3C
> 1. 循环时间长开销大
> 1. 只能保证一个共享变量的原子操作：将多个变量放在一个对象里进行CAS操作

## 自旋锁 VS 适应性自旋锁

自旋锁被其他线程占用，调用者不放弃处理器的执行时间，循环等待，看锁的持有者是否是已经释放了锁。自旋次数默认是10次。

在JDK1.6引入了自适应的自旋锁。自旋时间不在固定，而是由上一次同一锁上自旋时间和锁拥有者的状态来决定。

##  无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

- 无锁

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

- 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

- 轻量级锁

偏向锁存在其他线程竞争时，就会升级为轻量级锁；其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

- 重量级锁

等待锁的线程都会进入阻塞状态。

## 公平锁 VS 非公平锁

等待队列，是否插队。

Synchronized是非公平锁。


## 参考

[Java 之 synchronized 详解](https://juejin.im/post/594a24defe88c2006aa01f1c)

[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)
