---
layout:     post
title:      布隆过滤器实现原理与应用场景
subtitle:    "\"bloom filter\""
date:       2019-11-05
author:     Jimmy
header-img: img/manli-business-suit-manned.jpg
catalog: true
tags:
    - 布隆过滤器
    - bloom filter
---

> “🙉🙉🙉 ”

## 应用场景

如何判断一个元素是否在一个集合里？例如：

> 1.  字处理软件中，需要检查一个英语单词是否拼写正确
> 1.  在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上
> 1.  在网络爬虫里，一个网址是否被访问过
> 1.  yahoo, gmail等邮箱垃圾邮件过滤功能

常见的解决方案就是用数组、链表、树、平衡二叉树、Map、哈希表等来处理，但是当元素集合中的元素数量足够大时，用这些常规的数据结构来处理那问题就出来了，其消消耗的内存会线性增长，最终达到瓶颈。

所以布隆过滤器就应用而生啦。

## 布隆过滤器原理

布隆过滤器核心实现是一个超大的位数组和几个哈希函数，假设位数组的长度为m，哈希函数的个数为k。

具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。

### 添加元素流程
> 1.  将要添加的元素给K个哈希函数
> 1.  得到对应数组上的K个位置
> 1.  将K个位置设为1

### 查询元素流程
> 1.  将要查询的元素给K个哈希函数
> 1.  得到对应数组上的K个位置
> 1.  如果K个位置上有一个为0，则该元素肯定不在集合中
> 1.  如果K个位置全部为1，则该元素可能在集合中

### 支持删除么

目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。

如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。

## 如何选择哈希函数的个数和布隆过滤器长度



## 参考

[布隆过滤器(Bloom Filter)的原理和实现](https://www.cnblogs.com/cpselvis/p/6265825.html)

[详解布隆过滤器的原理，使用场景和注意事项](https://zhuanlan.zhihu.com/p/43263751)
