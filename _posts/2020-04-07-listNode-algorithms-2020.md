---
layout:     post
title:      Redis相关知识
subtitle:    "\"redis\""
date:       2020-03-30
author:     Jimmy
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - Redis
---


1、应用场景
1）Session共享(单点登录)
2）页面缓存
3）队列
4）排行榜/计数器
5）发布/订阅


2、Redis与Memcached区别比较
（1）Redis支持更丰富的数据结构，比如list、set、zset、hash、bitmaps、hyperLog，但是memcached只支持string（新增二进制类型）
（2）Redis支持数据备份，即master-slave模式的数据备份
（3）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时可以再次加载使用，而memcached把数据全部保存在内存中
（4）Redis的速度更快（数据存储在内存中，类似于hashMap，查找和操作时间复杂度都是O(1)）
（5）网络IO模型：Redis是单线程IO复用模型，而memcached是多线程非阻塞IO复用网络模型

3、怎么保证Redis中的数据都是热点数据？Redis有哪些数据淘汰策略？
（1）volatile-lru：从已设置过期时间的数据集中选择最近最少使用的数据淘汰
（2）volatile-ttl：从已设置过期时间的数据集中选择将要过期的数据淘汰
（3）volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
（4）allkeys-lru：从数据集中选择最近最少用的数据淘汰
（5）allkeys-random：从数据集中任意选择数据淘汰
（6）no-enviction：禁止淘汰，返回错误

4、Redis并发竞争问题？

5、Redis内存回收算法：LRU（hashMap+双向链表的实现）

6、Redis分区？
优点：扩展计算能力；允许构造更大的数据库
缺点：涉及多个key操作不被允许；涉及多个key的事务不被支持；数据处理更加复杂；增加或者删除容量也比较复杂

分区类型：
范围分区：0-10000分配在实例1；10001-20000分配在实例2，缺点是需要维护一个区间范围到实例的映射表
哈希分区：涉及到一致性hash的问题


7、持久化方式
（1）RDB快照存储
（2）AOF追加文件存储

8、Redis集群方案怎么做？
1、codis，目前用的最多的集群方案，支持在节点数量改变的情况下，旧节点数据可恢复到新的hash节点。
2、redis cluster3.0自带集群，分布式算法不是一致性hash，而是hash槽的概念，以及自身支持设置从节点
3、从业务代码层实现

1、Redis缓存的数据一致性
数据分为最终一致和强一致性，redis无法保存强一致性。

写操作：先清除缓存，再更新数据库，在更新缓存。
读操作：查询缓存，命中则直接返回；否则查询数据库，更新缓存，返回结果

但是对于并发读写操作，需要对key使用分布式锁来保证数据的一致性。

2、Redis过期淘汰
存储数据的时候可以设置过期时间，redis的过期删除采用的是定时删除，默认100ms检查一次，随机检查key是否过期，遇到过期的key就直接删除，这样操作有漏网之鱼。
redis还存在一种惰性删除策略，当我们去读写一个已经过期的key时，直接删除过期的key。

内存淘汰涉及淘汰策略。

3、缓存穿透
大量请求查询数据库中不存在的数据，缓存中查不到该数据，数据库由于压力大而垮掉。

解决方案：
（1）缓存空值：将不存在key对应的值设置为null丢到缓存中，下次再次查询该key时直接返回null。适合重复查询不存在数据的场景。

（2）布尔过滤器

4、缓存击穿

在高并发的系统中，大量的请求同时查询一个key，而该key此时正好失效了，就会导致大量的请求打到数据库上去。

使用互斥锁锁住第一个查询请求，其他线程等第一个线程查询到了数据并做了缓存后查询，走缓存。

5、缓存雪崩

某一时刻发生大规模缓存失效，比如缓存服务宕机。

（1）使用集群缓存，保证缓存服务高可用
（2）ehcache本地缓存+hystrix限流&降级
（3）开启redis持久化机制，尽快恢复缓存集群



6、热点数据集中失效？

（1）设置不同的失效时间，让缓存的过期时间错开
（2）互斥锁


